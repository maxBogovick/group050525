# Lesson 17


### Линейный поиск

Линейный поиск — это простой алгоритм поиска, который итерирует через все элементы в массиве, проверяя каждый элемент на соответствие искомому значению. Если элемент найден, алгоритм возвращает его индекс. Если элемент не найден до конца массива, возвращается `-1`, указывая на то, что элемент отсутствует в массиве. Вот пример реализации линейного поиска на Java:

```java
public class LinearSearch {

    public static int linearSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i; // Возвращаем индекс найденного элемента
            }
        }
        return -1; // Элемент не найден
    }

    public static void main(String[] args) {
        int[] arr = {3, 45, 1, 2, 8, 19}; // Пример массива
        int target = 8; // Элемент, который мы хотим найти

        int result = linearSearch(arr, target);

        if (result == -1) {
            System.out.println("Элемент не найден в массиве.");
        } else {
            System.out.println("Элемент найден на позиции: " + result);
        }
    }
}
```

В этом примере метод `linearSearch` принимает массив `arr` и искомое значение `target`. Метод проходит по массиву от начала до конца, сравнивая каждый элемент с `target`. Если совпадение найдено, метод немедленно возвращает индекс этого элемента. Если после проверки всех элементов совпадение не найдено, метод возвращает `-1`, указывая на отсутствие элемента в массиве.

Линейный поиск особенно эффективен для небольших или неотсортированных массивов, где применение более сложных алгоритмов поиска, таких как бинарный поиск, не оправдано из-за их предварительных требований (например, необходимость сортировки массива).


### Бинарный поиск

Бинарный поиск — это эффективный алгоритм поиска, который использует принцип деления пополам для нахождения элемента в отсортированном массиве. Этот метод значительно ускоряет поиск по сравнению с линейным поиском, особенно для больших массивов, так как количество сравнений сокращается с линейного до логарифмического.

### Принцип работы

1. **Инициализация:** Определите два указателя — начало (`left`) и конец (`right`) массива, которые обозначают границы поиска.
2. **Нахождение среднего элемента:** На каждом шаге алгоритма вычислите индекс среднего элемента (`mid`) как `(left + right) / 2`.
3. **Сравнение среднего элемента с искомым значением:**
    - Если средний элемент равен искомому (`target`), поиск завершается успешно.
    - Если средний элемент меньше `target`, сужаем область поиска к правой половине, устанавливая `left` на `mid + 1`.
    - Если средний элемент больше `target`, сужаем область поиска к левой половине, устанавливая `right` на `mid - 1`.
4. **Повторение:** Повторяйте шаги 2 и 3, пока `left` не станет больше `right`.
5. **Завершение поиска:** Если искомый элемент найден, возвращается его индекс. Если же область поиска исчерпана, и элемент не найден, возвращается `-1`.

### Сложность

Бинарный поиск имеет временную сложность O(log n), где n — количество элементов в массиве. Это делает его невероятно эффективным для поиска в больших массивах.

### Примечания

- Бинарный поиск применим только к отсортированным массивам или коллекциям. Если массив не отсортирован, его сначала необходимо отсортировать, что может увеличить общую временную сложность операции поиска.
- Бинарный поиск может быть реализован как в итеративной, так и в рекурсивной форме. Итеративный подход обычно предпочтительнее с точки зрения использования памяти, так как он избегает дополнительного стека вызовов, требуемого для рекурсии.



Алгоритмы сортировки - это основные методы, используемые для упорядочивания элементов в списке. Среди них наиболее известны и понятны начинающим программистам являются сортировка пузырьком, сортировка вставками и сортировка выбором. Каждый из этих алгоритмов имеет свои особенности, преимущества и недостатки.

### Сортировка пузырьком

Сортировка пузырьком - один из самых простых методов сортировки. Его принцип заключается в повторяющихся проходах по списку, в ходе которых соседние элементы сравниваются и, если они находятся в неправильном порядке, меняются местами. Такие проходы повторяются до тех пор, пока список не будет полностью отсортирован. Основной недостаток сортировки пузырьком - ее низкая эффективность на больших списках данных, поскольку время выполнения возрастает квадратично с увеличением количества элементов.

### Сортировка вставками

Сортировка вставками работает путем построения отсортированного массива (или списка) один элемент за разом, беря каждый следующий элемент из неотсортированной части и вставляя его в правильное место в уже отсортированной части. Этот метод хорошо работает на небольших списках или на списках, которые уже частично отсортированы, поскольку в таких случаях он требует меньшего количества перемещений. Время выполнения сортировки вставками также возрастает квадратично, но она часто работает быстрее, чем сортировка пузырьком, особенно на частично отсортированных данных.

### Сортировка выбором

Сортировка выбором основана на идее нахождения минимального (или максимального) элемента из неотсортированной части списка и обмена его с первым неотсортированным элементом. Затем процесс повторяется для оставшейся части списка до тех пор, пока все элементы не будут отсортированы. Этот метод сортировки имеет постоянное время выполнения независимо от изначального порядка элементов, что делает его квадратичным по времени в любом случае. Несмотря на то что сортировка выбором не является самой быстрой на практике, она проста в реализации и эффективна при сортировке небольших массивов.

Каждый из этих алгоритмов имеет свои сценарии использования и может быть более предпочтителен в зависимости от конкретных условий задачи и размера набора данных. Важно понимать их принципы работы, чтобы правильно выбирать алгоритм сортировки для конкретной задачи.

Давайте рассмотрим подробнее реализацию трех базовых алгоритмов сортировки (пузырьком, вставками и выбором) на языке программирования Java. Эти алгоритмы применимы к массивам, и каждый из них имеет свои особенности в плане реализации и производительности.

### 1. Сортировка пузырьком (Bubble Sort)

Сортировка пузырьком работает путем последовательного сравнения и обмена соседних элементов, если они находятся в неправильном порядке. Этот процесс повторяется до тех пор, пока массив не будет полностью отсортирован.

```java
public class BubbleSort {
    void bubbleSort(int arr[]) {
        int n = arr.length;
        for (int i = 0; i < n-1; i++)
            for (int j = 0; j < n-i-1; j++)
                if (arr[j] > arr[j+1]) {
                    // swap arr[j+1] and arr[j]
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
    }
}
```

### 2. Сортировка вставками (Insertion Sort)

Сортировка вставками разделяет массив на отсортированную и неотсортированную части. Она работает, взяв каждый элемент из неотсортированной части и вставив его в правильное место в отсортированной части.

```java
public class InsertionSort {
    void insertionSort(int arr[]) {
        int n = arr.length;
        for (int i = 1; i < n; ++i) {
            int key = arr[i];
            int j = i - 1;

            /* Move elements of arr[0..i-1], that are
               greater than key, to one position ahead
               of their current position */
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j = j - 1;
            }
            arr[j + 1] = key;
        }
    }
}
```

### 3. Сортировка выбором (Selection Sort)

Сортировка выбором ищет минимальный элемент в неотсортированной части массива и ставит его в начало. Этот процесс повторяется для всех элементов массива.

```java
public class SelectionSort {
    void selectionSort(int arr[]) {
        int n = arr.length;

        // One by one move boundary of unsorted subarray
        for (int i = 0; i < n-1; i++) {
            // Find the minimum element in unsorted array
            int min_idx = i;
            for (int j = i+1; j < n; j++)
                if (arr[j] < arr[min_idx])
                    min_idx = j;

            // Swap the found minimum element with the first
            // element
            int temp = arr[min_idx];
            arr[min_idx] = arr[i];
            arr[i] = temp;
        }
    }
}
```

Каждая из этих реализаций представляет собой базовый пример соответствующего алгоритма сортировки.
Важно помнить, что на практике могут потребоваться дополнительные оптимизации или выбор более эффективного алгоритма в зависимости от размера и особенностей данных.



