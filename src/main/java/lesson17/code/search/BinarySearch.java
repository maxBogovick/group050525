package lesson17.code.search;

import java.util.Arrays;

public class BinarySearch {
    public static void main(String[] args) {

        /*
        {10,29,33,47,52,643,723,818,999} - исходный массив

        предположим, что нам надо найти индекс для элемента 47

        то есть, ответить на вопрос - есть ли такой элемент и какой у него индекс если он есть

        1-я итерация
        находим средний элемент нашего массива -> индекс = 4, element = 52
        далее мы сравниваем наш элемент поиска и "середину" и смотрим больше или меньше значение

        так как наш элемент поиска МЕНЬШЕ значения "середины", то это означает, что
        поскольку массив отсортирован по возрастанию в правой части массива
        нашего элемента НЕ МОЖЕТ быть

        то нас интересует только ЛЕВАЯ часть массива ("левая половинка")

        2-я итерация происходит только с "левой" частью,
        то есть мы будем продолжать поиск среди {10,29,33,47,52}

        находим середину -> index = 2, значение = 33
        так как наш элемент поиска БОЛЬШЕ чем середина, то
        будем продолжать поиск среди "правой" части: {33,47,52}


         3-я итерация

        находим середину -> index = 3, значение = 47
        наш элемент совпал с элементом массива, нужный индекс = 3

        //---------------------------------------------------

        {1,3,5,7,9,12,15,19,21,26,29,35,39,43,48,50,100} - 17 элементов

        ищем число = 19

       17 / 2 = 8.5
       int(8.5) = 8

       1 ->
            {1,3,5,7,9,12,15,19,21,26,29,35,39,43,48,50,100}
            середина = 21, индекс = 8

            сравниваем наш элемент поиска 19 со значением элемента массива с индексом 8 (значение 21)

       2 -> проводится среди элементов "левой" части массива
            {1,3,5,7,9,12,15,19,21}
            середина будет иметь индекс = 4 со значением = 9

            сравниваем наш элемент поиска 19 со значением элемента массива с индексом 4 (значение 9)

       3 -> проводится среди элементов "правой" части массива
            {9,12,15,19,21}
            середина будет иметь индекс = 6 со значением = 15

            сравниваем наш элемент поиска 19 со значением элемента массива с индексом 6 (значение 15)


       4 -> проводится среди элементов "правой" части массива
            {15,19,21}
            середина будет иметь индекс = 7 со значением = 19

            сравниваем наш элемент поиска 19 со значением элемента массива с индексом 7 (значение 19)

            элементы равны, искомый индекс = 7


            Если у нас в массиве количество элементов = 1 000 000, то количество шагов для поиска будет равно: 20 итераций

            1 000 000
              500 000
              250 000
              125 000
               62 500
               31 250
               15 625
                7 812
                3 906
                1 953
                  976
                  488
                  244
                  122
                   61
                   30
                   15
                    7
                    3
                    1

Сложность алгоритма поиска - логарифмическая - O(log n)

         */

        int[] arrayForSearch = {1,3,5,7,9,12,15,19,21,26,29,35,39,43,48,50,100};

        int elementForSearch = 19;

        SearchInArray search = new SearchInArray();

        int indexSearch = search.binarySearch(arrayForSearch, elementForSearch);

        if (indexSearch >= 0 ) {
            System.out.println("Число: " + elementForSearch + " найдено в массиве и имеет индекс: " + indexSearch);
        } else {
            System.out.println("Число: " + elementForSearch + " в массиве не найдено");
        }

        // найдем индекс для числа 29

        System.out.println("Индекс числа 29 -> " + Arrays.binarySearch(arrayForSearch, 29));
    }
}
